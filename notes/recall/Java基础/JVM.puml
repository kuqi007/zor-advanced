@startmindmap
'https://plantuml.com/mindmap-diagram

* JVM
** JVM内存布局
*** 堆（线程共享）
**** 几乎所有的对象和数组都在堆上分配
**** 新生代：Eden+S0+S1
**** 老年代
*** 元空间（线程共享，jdk1.7之前叫方法区）
**** 方法元信息/类元信息/常量池
*** 虚拟机栈（线程私有）
**** 局部变量表/操作栈/动态连接/方法返回地址
*** 本地方法栈（线程私有）
**** 给native方法用的，和虚拟机栈类似
*** 程序计数器（线程私有）
**** 唯一不会发生OOM的区域
**** 占用很小的一片区域，记录当前执行的行数

** new一个对象，堆内存分配策略
***:1.先判断是否可以栈上分配，优先分配到当前线程栈帧（逃逸分析，对象未逃出当前方法作用域，无外部引用）
2.TLAB快速分配，避免多线程竞争锁：每个线程在Eden区划出线程私有内存块，TLAB总空间是默认Eden区1%大小，可以修改（ThreadLocalAllocationBuffer）
3.共享Eden区分配：如果TLAB分配失败，则到Eden区分配，Eden区空间不足，触发Minor GC
4.大对象直接入老年代（避免复制开销）：对象大小≥PretenureSizeThreshold直接进入老年代;

** 双亲委派模型\n（决定由哪个类加载器加载）
***:Bootstrap ClassLoader(Top)
Ext ClassLoader
App ClassLoader
Custom ClassLoader(Bottom);
***:逐层向上询问类是否已加载，如果已加载或上层可以加载，由上层加载；
否则由自定义加载器自己加载;
*** 破坏双亲委派
**** 自定义类加载器，重写loadClass方法
**** Tomcat自定义的WebAppClassLoader绕开AppClassLoader，顺序是Ext->Boostrap->webapp->app，最后才使用appCL
**** JAVA SPI机制，发起者BootstrapClassLoader已经是最上层了，直接获取了AppClassLoader进行加载，跟双亲委派是反的
**** 动态代理，运行时生成代理类

** 类加载过程
***:实际加载的过程Load，Link，Init：
Load：初步校验魔法数、常量池、文件长度、是否有父类等，创建对应java.lang.Class类
Link：验证、准备、解析三个阶段。验证final是否合规、类型是否正确、静态变量是否合理；
          准备阶段为静态变量分配内存，设定默认值；
          解析类和方法确保类和方法相互引用正确性，完成内存布局。
Init：执行构造器<cinit>方法，如果赋值运算依赖其他类的静态方法，那么会解析另外一个类，执行完毕之后通过返回值进行复制;




** 对象实例化过程
***:1.查找类信息是否存在，没有则加载类
2.分配对象内存
3.设定成员变量的默认值
4.设置对象头
5.执行Init方法;

** 垃圾回收
*** GCRoots可达性分析
**** 对象如果跟GCRoots没有直接引用或间接引用关系，是可以被回收的
****:2次标记：
第一次标记筛选出实现了finalize()方法的对象，放入低优先级队列，异步逐个执行方法
第二次标记：下一次GC时，如果对象"自救"失败，则真正标记为可回收；如果重新建立引用，则变成存活对象;
****:那些对象可作为GCRoots：
类静态属性引用对象
常量引用的对象
虚拟机栈中引用的对象
本地方法栈中引用的对象;
*** 三色标记算法
*** 垃圾回收算法
**** 标记清除
***** 标记有引用关系的对象，将没有标记的对象清除
***** 易产生内存碎片，引发FGC
**** 标记整理
***** 标记存活的对象，将存活对象整理到内存空间一端，形成连续已用空间，再将之外的空间全部清理掉。
***** 解决了内存碎片问题
**** 复制算法
***** 内存分为2块，每次只用1块，GC时候把存活对象复制到未激活的空间，清除已激活空间所有对象，最后将2个空间交换
***** YGC主要用的算法，不易产生碎片；缺点是如果存活对象过多，复制效率大大降低
**** 分代收集
***** 新生代用复制，老年代用标记清除或标记整理

*** 垃圾回收器
**** CMS（标记清除）
*****: 1.初始标记、2.并发标记、3.重新标记、4.并发清除
* 1、3步会引发STW，2、4步可以并发执行，比较耗时但不影响应用正常执行
* 缺点：会产生大量内存碎片，可加参数强制FGC后压缩老年代，也可以配置在执行n次FGC后，再压缩;
**** G1（标记整理+复制算法）
*****:适合大内存（堆>6GB）
* 不产生内存碎片；可以精准控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收
* 分割成若干相同大小的region：Eden/Survivor/Old/Humongous
* 1.初始标记 2.根区域扫描 3.并发标记 4.重新标记 5.清除
* 1、4会触发STW;
**** ZGC（支持TB堆内存，最大GC停顿100ms）

*** 如何配置垃圾回收器参数
****:*每个区域配置内存上限，避免OOM
* 堆空间配置成系统内存的2/3，超过8GB堆，优先选用G1
* 根据老年代对象提升速度，调整年轻代和老年代之间的比例
* 根据系统容量、访问延迟、吞吐量等进行专项优化，高并发系统应尽量减少STW时间
* 记录详细GC日志，找到瓶颈点，借用GCeasy工具，定位问题;







** 空间分配担保\n（Allocation Handle Promotion）
***:每次Minor GC前判断
*确保存活对象能安全进入老年代而设计的风险评估机制。
*其核心目的是在年轻代空间不足时，通过老年代的空间兜底来避免频繁 Full GC。
*避免无效 Minor GC：若老年代无法兜底存活对象，提前触发FGC比MinGC失败再FGC更高效
*减少Full GC触发频率：通过前置检查避免因晋升失败而触发昂贵的FGC
*防止过早OOM：严格检查确保存活对象有去向（若完全不担保，MinGC后存活对象无处存放直接OOM）;
@endmindmap
