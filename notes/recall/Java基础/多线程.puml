@startmindmap
'https://plantuml.com/mindmap-diagram

* 多线程

** 线程与进程
*** 线程几种状态\n（easy coding p225）
****:NEW（新建）
RUNNABLE（就绪）
RUNNING（运行）
BLOCKED（阻塞：BLOCKED/WAITING/TIMED_WAITING）
DEAD（终止）;
*** 线程状态之间的切换
****:NEW.start() = RUNNABLE
RUNNABLE.threadReady = RUNNING
RUNNING.lock/wait/timed_wait = BLOCKED
BLOCKED.notify = RUNNING
RUNNING.stop() = DEAD;


** ThreadLocal
*** 每个线程维护ThreadLocalMap(键为弱引用的ThreadLocal，值为强引用的存储数据）
*** get()/set() 操作基于当前线程的ThreadLocalMap 实现隔离
*** 内存泄漏（最严重问题）：弱引用key被回收后，Value因强引用无法回收->需手动调用remove()
*** 线程池中线程复用导致数据污染，需手动调用remove()

** 线程池

***:JDK提供的默认线程池问题：队列长度为Int最大值，或最大线程数为Int最大值，导致OOM
需要手动设置ThreadPoolExecutor的参数;
*** 线程池参数如何设置：CPU密集型、IO密集型
***:1.入口是execute方法
2.任务提交到线程池后，判断是否需要添加worker
3.worker添加成功后，worker里包装了一个thread，此时会start这个thread
4.thread启动之后，会调用runWorker
5.runWorker方法会不停去getTask()方法获取阻塞队列里的任务，如果返回null，则退出当前线程
6.如果是非核心线程或核心线程允许被回收，会去超时等待拿任务，等待后拿不到任务，会返回null，线程会被回收
7.从workers里面移除当前Worker对象，线程对象失去引用，由JVM垃圾回收。;


***: 从源码出发，为什么非核心线程空闲keepAliveTime后，会被回收
getTask()方法里：workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)
当超时控制的线程拿任务，数量为0，会等待keepAliveTime的时间，如果最后为null，则回收线程;
***:1.线程超时，队列没有任务，回收当前线程
2.线程超时，当前线程数大于1，回收当前线程;

** 乐观锁与悲观锁
*** CAS缺点
**** ABA问题：加版本号解决，比如AtomicStampedReference
**** 自旋消耗资源：自旋一直不成功，将一直占用CPU；超时或超过最大次数则放弃，或使用LongAdder（分段）
**** 只能保证一个共享变量的原子操作：加锁或封装成对象（AtomicReference）

** synchronized
***: synchronized依赖对象头的Mark Word来存储锁状态
无论加在哪里都是锁对象：Class对象或实例对象，判断锁是加在Class对象还是实例对象上;
*** 同步实例方法：锁住当前实例对象(this)
*** 同步静态方法/类：锁住类的Class对象
*** 同步代码块：锁住显式指定的任意对象


** synchronized\n锁升级/锁膨胀
*** 无锁状态（无竞争）
***:偏向锁：
* 单线程重复访问同步块
* 通过对象头记录线程ID（无需CAS）
* 占用少量内存记录线程ID;
***:轻量级锁：
* 多线程轻度竞争
* 通过CAS自旋尝试获取锁（JVM自适应自旋）
* CPU自旋消耗（短时间无阻塞）;
***:重量级锁：
* 竞争激烈（自旋失败）
* 线程阻塞，交由操作系统调度（涉及到用户态/内核态转换）
* 操作系统级互斥量（Mutex），上下文切换开销大;

** ReenTrantLock
***:可重入锁
CAS实现
公平锁（也可选不公平）
需要手动释放
可以中断：trylock(long timeout,TimeUnit unit)设置超时方法或使用lockInterruptibly()，调用interrupt方法进行中断;

** 公平锁跟非公平锁的区别
***:公平锁：
严格按照申请顺序（FIFO），先检查等待队列非空，有"人"等待则直接排队
优点：无线程饥饿，保证公平性
缺点：吞吐低，除了第一个线程，其他都会阻塞，cpu频繁唤醒进程开销大;
***:非公平锁：
允许"插队"：新线程可以直接尝试CAS获取锁，失败才排队
优点：吞吐高，减少线程唤醒开销，减少CPU上下文切换
缺点：队列里中的线程可能会一直获取不到锁;

** 锁优化
***:使用层面进行锁优化：
*缩小锁粒度：减少同步代码块里代码；一个锁拆成更小的锁，如LongAdder，java8 ConcurrentHashMap
* 锁粗化：相邻多次锁操作的代码合并为单次锁，减少锁切换
* 读写锁
*无锁编程：CAS，ThreadLocal等;
*** 系统层面:\n锁消除：虚拟机判断代码不存在锁竞争，会对锁进行消除

** JAVA内存模型（JMM）
*** 原子性
**** volatile、synchronized、原子类，可以实现原子性，但volatile不支持i++操作的原子性。
*** 可见性
**** volatile、synchronized、原子类、final关键字，都可以实现原子性
*** 有序性
**** volatile禁止指令重排序实现有序性；synchronized保证同一时刻只有一个线程访问，实现有序性

** AQS

@endmindmap
