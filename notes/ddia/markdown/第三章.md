# 第三章 数据存储与检索

## 实现一个简单的哈希索引

**核心思想**

1. 维护一个内存的hash map，key是实际的key，value是内容key+value
2. 实际内容存到磁盘上，只往文件最后追加，不修改，磁盘写入速度很快
3. 插入键：追加一条到文件末尾，内存hash map添加一个键，包含key跟offset；
4. 更新键：追加一条到文件末尾，更新已有的hash map中的offset
5. 因为文件写入是顺序的，所有一般只有一个写线程。
6. 而且数据文件段是追加的，且不可变的，所以可以被多个线程同时读取。
7. 后台会自动压缩合并去重
8. 性能会比较高

**哈希索引的结构**

> 1. hashmap的k数据的key，以及实际内容在磁盘上的offset，类似：mem:2103
> 2. 数据实际的key-value的内容存到磁盘上，通过hashmap的offset来查找实际内容

**数据在磁盘上是如何存储的？**

> 数据只追加到文件末尾，不修改，因为顺序追加，不涉及到随机读写，磁盘写入是很快的。

**追加文件貌似很浪费空间，为什么不原地更新文件呢，用新的值覆盖旧的值呢？**

> - 追加跟分段合并主要是顺序写，在旋转式磁盘上速度很快；顺序写入在SSD上也是适合的
> - 如果段文件是追加且不可变的，则并发和崩溃恢复要简单的多。例如，不用担心在重写值时发生崩溃的情况，留下一个包含旧值跟部分新值混在在一起的文件
> - 合并旧段可以避免随着时间的推移数据文件出现碎片化的问题，
> - 如果我是去原地更新旧的值，新值跟旧值长度不一样，会导致旧段出现上某些值offset发生便宜，需要同步去更新内存中hash map。

**如何更新一个键的值**

> 磁盘上直接追加一条新的值，并更新内存哈希表的offset，旧的值会在段文件压缩合并过程中被放弃掉。

**段文件的压缩跟合并**

> 为了防止但文件大小爆炸，当达到一定大小后，关闭这个文件，后续写入到新的段文件中
>
> 同一个段文件可以执行压缩，即合并重复的值，以最新的为准
>
> 不同段文件也可以合并
>
> 先后台生成新的合并后的段文件，生成过程中旧文件仍可以继续读取以及写请求；合并完成后，将读取请求切换到新文件。

**查找过程**

> 每个段都有自己的内存哈希表，将键映射到文件的偏移量；
>
> 先查找最新哈希表，如果没有则查找第二新的哈希表；
>
> 由于合并过程可以维持较少的段，所以不需要检查很多的哈希表

## SSTable

SSTable存储的也是键值对，但要求按键排序。这种格式成为排序字符串表，或简称SSTable。他要求每个键在每个合并的段文件中只能出现一次（在压缩过程中已经确保了）。

SSTable有几个很大的优势：

1. 合并更加简单高效，即使文件大于可用内存。方法类似于合并排序算法。并发读取多个输入文件段，比较每个文件的第一个键，把最小的键（根据顺序排序）拷贝输出文件，并重复这个过程。这会产生一个新的按键排序的合并段文件。
   如果出现多个相同的键在多个输入段怎么办？每个段包含在某段时间内写入的所有值。某一个输入段中的所有值肯定比其他段中所有值更新（假设总是合并相邻的段）。当多个段包含相同的键时，可以保留最新段的值，并丢弃旧段中的值。
2. 在文件中查找特定的键时，不需要在内存中保存所有的键的索引。因为每个段文件都是按顺序排序的，只要维护一个稀疏的内存索引来记录某些键的偏移，一般来说，稀疏索引的每个条目指向压缩块的开头。

### 构建和维护SSTable

存储在内存中会比较容易，比如红黑树或AVL树，使用这些数据结构，可以按任意顺序插入键并以排序后的顺序读取他们。

存储引擎的基本工作流程如下：

- 当写入时候，将数据写入到内存的平衡树结构中（例如红黑树），这个内存中的树有时被称为内存表
- 当内存表大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入到磁盘中。由于树已经维护了按键排序的key-value对，写磁盘可以比较高效。新的SSTable文件成为数据库的最新部分。当SSTable写磁盘的同时，写入可以继续添加到新的内存表实例。
- 为了处理读请求，首先尝试在内存表中查找该键，然后是新的磁盘段文件，接下来是次新的磁盘段文件，以此类推，知道找到新目标（或为空）。
- 后台进程周期性地执行压缩与合并，以合并多个段文件，并丢弃那些已被覆盖或删除的值。

上述方案可以很好的工作，但存在一个问题：如果数据库崩溃，最近的写入（在内存表中但尚未写入磁盘）将会丢失。为了避免该问题，可以在磁盘中保留单独的日志，每个写入都会立即追加到该日志，就像上一节所述。日志文件不需要按键排序，这并不重要，因为它的唯一目的是在崩溃后恢复内存表。每当将内存表写入SSTable时，相应的日志可以被丢弃。

### LSM-Tree

